# Language Guide

This document serves as a comprehensive guide to the Luma language syntax and
features. Luma is a dynamic, scripting language designed for easy embedding,
featuring familiar C-style syntax with powerful functional and object-oriented
capabilities.

## Variables and Scope

Luma uses dynamic typing. Variables do not need type declarations.

### Assignment and Access

Variables are assigned using the `=` operator. Variables are mutable by default.

```luma
x = 10
print(x) // 10

x = 20
print(x) // 20
```

### Scoping and Shadowing

Luma supports global and local scopes. By default, functions can read and write
to global variables. To shadow a global variable (create a new variable with
the same name in the local scope), use the `local` keyword.

```luma
x = "global"

fn test_scope():
    print(x)           // Accesses global 'x'
    local x = "local" // Declares a new local 'x'
    print(x)           // Accesses local 'x'

test_scope()
print(x)               // Global 'x' remains "global"

```

## Data Types & Arithmetic

Luma handles integers and floating-point numbers seamlessly, maintaining
precision for complex calculations.

### Arithmetic Operators

Standard operators are supported: `+`, `-`, `*`, `/`. Luma follows standard
order of operations (PEMDAS).

```luma
print(10 + 5 * 2)   // 20
print((10 + 5) * 2) // 30

```

### Exponents and Modulo

Luma includes built-in operators for exponentiation (`^`) and modulo (`%`).

```luma
print(2 ^ 3)   // 8 (Exponent)
print(10 % 3)  // 1 (Remainder)

```

> **Note:** Exponents are right-associative (e.g., `2 ^ 3 ^ 2` is `2 ^ 9`, not `8 ^ 2`).

### Boolean Logic

Luma supports `true` and `false`. Comparison operators include `==`, `!=`, `<`,
`>`, `<=`, `>=`. You can use symbols (`!`, `&&`, `||`) or keywords (`not`,
`and`, `or`).

```luma
if 10 > 5 and 5 < 20:
    print("Math works")
    
if "name" in player:
    print("Player exists")
```

## Strings

Strings in Luma are powerful and support multi-line definitions and complex
interpolation.

### Concatenation and Multi-line

Strings can be added using `+` or defined across multiple lines.

```luma
// Concatenation
print("Hello, " + "World!")

// Multi-line
print("
    Line 1
    Line 2
")
```

### String Interpolation

You can embed variables and expressions directly into strings using `{}`
syntax.

```luma
name = "Alice"
print("Hello, {name}!")

a = 5
b = 10
print("The sum is {a + b}")
```

> [!TIP] To use a literal brace, escape it: `print("This is a brace \{ ")`.

## Arrays

Arrays are ordered lists of data. They are zero-indexed and dynamic.

### Declaration and Access

```luma
// Declare an array of integers.
arr = [10, 20, 30]

// Access by index.
print(arr[0]) // 10

// Modify the second element.
arr[1] = 99

// Grab the size.
print(arr.length) // 3
print(arr.size) // 3 (alias of .length)

// Print the result
for item in arr:
    print(item)
```

### Array Methods

Luma arrays come with built-in methods for stack and queue operations.

* `push(item)`: Add to end.
* `pop()`: Remove and return from end.
* `unshift(item)`: Add to start.
* `shift()`: Remove and return from start.
* `slice(start, end)`: Return a sub-array.
* `splice(start, count)`: Remove items and return them.
* `reverse()`: Return a reversed copy.

```luma
arr = [1, 2, 3]
arr.push(4)
last = arr.pop()
```

### Array Comprehensions

You can create new arrays based on existing ones using Python-like
comprehension syntax.

```luma
nums = [1, 2, 3, 4, 5]
squared = [x * x for x in nums] 
// Result: [1, 4, 9, 16, 25]
```

## Objects

Objects are key-value pairs (dictionaries). Keys are strings (implied or
explicit).

### Declaration

You can use standard JSON-style syntax or a simplified syntax without commas.

```luma
// Standard
player = {
    name: "Alice",
    score: 100
}

// Simplified
enemy = {
    type: "Goblin"
    hp: 50
}
```

### Access and Checking Keys

Access properties via dot notation (`obj.prop`) or brackets (`obj["prop"]`).
Use `in` to check for the existence of keys.

```luma
print(player.name)

if "score" in player:
    print("Player has a score")
```

### Object Comprehensions

Similar to arrays, you can build objects dynamically.

```luma
names = ["alice", "bob"]

// Create a map of name -> length
lengths = { name: 10 for name in names }

// Result: { "alice": 10, "bob": 10 }
```

## Control Flow

### If / Else

Standard conditional logic.

```luma
if x > 10:
    print("High")
else:
    print("Low")
```

### Loops (For, While, Do-While)

Luma supports multiple looping constructs.

**For Loops:** Iterate over arrays or ranges.

```luma
// Range (0 to 4)
for i in 0..5:
    print(i)

// Array
for item in [10, 20, 30]:
    print(item)
```

**While Loops:** Run while a condition is true.

```luma
count = 0
while count < 5:
    count = count + 1
```

**Do-While:** Run at least once.

```luma
do:
    print("Run once")
while false
```

### Break and Continue

Use `break` to exit a loop early, and `continue` to skip to the next iteration.

## Functions

Functions are first-class citizens in Luma.

### Declaration and Return

Functions are defined using the `fn` keyword.

```luma
fn add(a, b):
    return a + b

result = add(5, 10)
```

### Recursion

Functions can call themselves.

> [!TIP] Functions are hoisted, so they can be called before declaration.

```luma
print(fib(5)) // 5

fn fib(n):
    if n <= 1: return n
    return fib(n - 1) + fib(n - 2)
```

## Object-Oriented Programming

Luma features a robust class system with inheritance, constructors, and
interoperability.

### Class Definition & Constructors

You can define properties and methods. Constructors can be defined in two ways:

1. **Primary Constructor:** Defined in the class header.
2. **Init Method:** Defined as a method named `init`.

> [!INFO] You must choose **one** style for defining parameters; you cannot mix
> header parameters with `init` parameters.

```luma
// Primary Constructor Style
class Point(x, y):
    x = x
    y = y

// Init Method Style
class Rectangle:
    width = 0
    height = 0

    fn init(w, h):
        this.width = w
        this.height = h
```

> [!TIP] You can use `this` in primary constructors to avoid the boilerplate
> of assigning parameters to properties.

```luma
class Point(this.x, this.y)
```


### Instantiation

Use the `new` keyword to create instances.

```luma
p = new Point(10, 20)
print(p.x)

```

### Inheritance

Classes can extend other classes using `extends`. Use `parent` to access the
properties and methods of the parent class.

```luma
class Animal(this.name):
    fn speak():
        print("...")

class Dog(name) extends Animal(name):
    fn speak():
        parent.speak()
        print("Woof!")
```

### Type Checking

Use the `is` operator to check for instance types.

```luma
d = new Dog("Buddy")
print(d is Dog)    // true
print(d is Animal) // true
```

## Modules

Code can be organized into modules. By default, variables, classes and functions
in a module are **private**. You must use the `public` keyword to export them.

**math_lib.luma:**

```luma
// Private
secret = 42

// Public
public pi = 3.14
public fn add(a, b):
    return a + b
```

**main.luma:**

```luma
import "math_lib"

print(math_lib.pi)
print(math_lib.add(10, 20))
// print(math_lib.secret) // Error: Property does not exist
```

> [!INFO] **Singleton State:** Imported modules behave as singletons. If
> multiple files import "market", they share the exact same instance and state.

### Linking Modules in the VM

The VirtualMachine requires either a `moduleCache` object or a `resolveModule`
function to locate and load modules during execution.

```ts
const cache: Record<string, Program> = {};

const vm = new VirtualMachine(program, {
    moduleCache: cache,
    resolveModule: (name) => {
        if (! cache[name]) {
            cache[name] = Compiler.compile(`// module code for ${name}`);
        }
        
        return cache[name];
    }
});
```

> [!TIP] A module can also be a native JavaScript object. This allows you to
> expose host functionality in a controlled manner. Note that only
> **variables**, **objects** and **functions** can be exposed this way. Classes
> must be exposed via the `classes` configuration option.
 
## Runtime & Security

### Time Control

Luma includes a `wait` keyword to pause execution (useful for game loops or
throttling).

```luma
print("Start")
wait(1000) // Pauses for 1000ms
print("End")
```

> [!INFO] When invoking `vm.run()`, you can pass a _delta time_ value (in
> milliseconds) to simulate time passage for `wait` calls.

```ts
function gameLoop(deltaTime: number) {
    vm.run(deltaTime);
}
```

### Sandboxing

Luma is designed to be secure. The VM actively prevents access to the underlying
JavaScript host environment:

* **No Prototype Access:** `__proto__` and `prototype` access is forbidden.
* **No Constructor Escalation:** You cannot access `.constructor` to break out of the sandbox.
* **Frozen Globals:** Scripts cannot add new global variables to the host sandbox, ensuring isolation.

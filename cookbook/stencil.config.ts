import {Config}              from '@stencil/core';
import {sass}                from '@stencil/sass';
import chokidar, {FSWatcher} from 'chokidar';
import fs                    from 'node:fs';
import path                  from 'node:path';

const isWatchMode = process.argv.includes('--watch');

export const config: Config = {
    namespace:     'luma',
    srcDir:        'src',
    plugins:       [sass(), docsPlugin()],
    outputTargets: [
        {
            type:          'www',
            dir:           'dist',
            buildDir:      'build',
            empty:         true,
            serviceWorker: null, // disable service workers
            copy:          [
                {src: 'index.html'},
                {src: '404.html'},
                {src: 'Assets', dest: 'assets'},
                {src: '../node_modules/monaco-editor/min/vs', dest: 'vs'},
            ],
        },
    ],

    devServer: {
        port:           9000,
        openBrowser:    false,
        reloadStrategy: 'pageReload',
    },
};

function docsPlugin()
{
    return {
        name: 'external-watcher-plugin',
        // Run once when Stencil starts
        options()
        {
            if (isWatchMode) {
                docsWatcher();
            } else {
                docsBuilder();
            }
        },
    };
}

function docsWatcher(): void
{
    // Build once.
    docsBuilder();

    const docsDir: string    = path.resolve(__dirname, 'docs');
    const watcher: FSWatcher = chokidar.watch(docsDir, {ignoreInitial: true});

    let timer: NodeJS.Timeout | undefined;

    watcher.on('all', () => {
        clearTimeout(timer);
        timer = setTimeout(() => docsBuilder(), 500);
    });

    const closeWatcher = () => watcher.close();

    process.on('SIGINT', closeWatcher);  // CTRL+C
    process.on('SIGTERM', closeWatcher); // Kill command
}

function docsBuilder(): void
{
    const docsDir: string = path.resolve(__dirname, 'docs');
    const outFile: string = path.resolve(__dirname, 'src', 'docs.ts');

    const docs: any[] = collectDocs(docsDir, docsDir, []);
    const outSrc      = `// This file is auto-generated by stencil.config.ts\n\nexport const docs = ${JSON.stringify(docs, null, 4)};\n`;

    fs.writeFileSync(outFile, outSrc, 'utf-8');
}

function collectDocs(dir: string, baseDir: string, docs: any[]): any[]
{
    const files = fs.readdirSync(dir, {withFileTypes: true})
        .filter(de => de.isFile())
        .map(de => de.name);


    files.sort();

    for (const name of files) {
        const content: string  = fs.readFileSync(path.resolve(baseDir, name), 'utf-8');
        const baseName: string = path
            .basename(name, '.md')
            .replace(/^(\d+)\./, '')
            .replace(/'.md$/, '');

        const title = extractTitleFromMarkdown(content);
        if (! title) {
            continue; // Skip files without a title.
        }

        docs.push({
            title,
            content,
            path:  '/docs/' + title.replace(/\W+/g, '-').toLowerCase(),
            links: extractHeaderLinksFromMarkdown(content),
        });
    }

    return docs;
}

type HeaderLink = {
    text: string,
    link: string,
    children?: HeaderLink[]
}

type LinkStack = {
    level: number,
    node: HeaderLink
};

function extractTitleFromMarkdown(markdown: string): string | null
{
    const lines = markdown.split('\n');

    for (const line of lines) {
        const match = line.match(/^#\s+(.*)/);

        if (match) {
            return match[1].trim();
        }
    }

    return null;
}

function extractHeaderLinksFromMarkdown(markdown: string): HeaderLink[]
{
    const lines: string[]    = markdown.split('\n');
    const root: HeaderLink[] = [];
    const stack: LinkStack[] = [];

    for (const line of lines) {
        const match = line.match(/^(#{2,6})\s+(.*)/);

        if (match) {
            const level: number    = match[1].length;
            const text: string     = match[2].trim();
            const link: string     = '/' + text.toLowerCase().replace(/\W+/g, '-');
            const node: HeaderLink = {text, link};

            while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                stack.pop();
            }

            if (stack.length === 0) {
                root.push(node);
            } else {
                const parent = stack[stack.length - 1].node;

                if (!parent.children) {
                    parent.children = [];
                }

                node.link = parent.link + node.link;
                parent.children.push(node);
            }

            stack.push({level, node});
        }
    }

    return root;
}

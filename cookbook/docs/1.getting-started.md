# Getting Started

Ready to integrate Luma into your application? This guide will walk you through
installation, a basic usage example, and how to bridge the gap between your
host application and Luma scripts.

## Installation

Luma is available as a lightweight package via your favorite package manager.
Run one of the following commands in your terminal to add it to your project:

**Using npm:**

```bash
npm install luma-lang --save
```

**Using Yarn:**

```bash
yarn add luma-lang
```

**Using pnpm:**

```bash
pnpm add luma-lang
```

## Basic Usage

Once installed, the core workflow involves two main components: the
**Compiler** and the **VirtualMachine**. The compiler transforms Luma source
code into bytecode, which the VM then executes.

Here is a complete example of running a simple script that calculates the
Fibonacci sequence:

```ts
import { Compiler, VirtualMachine } from 'luma-lang';

// 1. Define your Luma script
const sourceCode = `
fn fib(n):
    if n <= 1: return n
    return fib(n - 1) + fib(n - 2)

result = fib(10)
print("The 10th Fibonacci number is: " + result)
`;

// 2. Compile the source code into a Program
const program = Compiler.compile(sourceCode);

// 3. Create a VM instance and run the program
const vm = new VirtualMachine(program);
vm.run();
```

**Output:**

```text
The 10th Fibonacci number is: 55
```

## Budgeting Execution

Luma's Virtual Machine supports a "tick budget" system that allows you to
control how many instructions a script can execute per tick. This is
particularly useful in game loops to prevent scripts from blocking the main
thread.

```ts
const vm = new VirtualMachine(program, {
    budget: 1000, // Limit to 1000 instructions per tick
});

let lastTime: number = performance.now();

// Your application/game loop:
function gameLoop() {
    const currentTime = performance.now();
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    vm.run(deltaTime); // Advance the VM by deltaTime milliseconds.
    
    requestAnimationFrame(gameLoop);
}
```

## Interoperability

One of Luma's most powerful features is its design for smooth interoperability
with JavaScript and TypeScript. You can expose host functions, classes, objects,
and variables to the runtime, enabling rich and secure interactions between the
host and the script.

### Exposing Host Classes

Luma allows you to map TypeScript classes to Luma classes. To ensure the script
environment remains sandboxed and secure, you must explicitly define which
properties and methods are accessible.

Consider a scenario where you want to expose an `Actor` class to your script:

```ts
import { Compiler, VirtualMachine } from 'luma-lang';

class Actor 
{
    public name: string;

    constructor(name: string = "Unknown") {
        this.name = name;
    }

    greet() {
        console.log(`Hello, ${this.name}!`);
    }
}

const source = `
actor = new Actor()
actor.name = "Luma User"
actor.greet()
`;

const program = Compiler.compile(source);

// Configure the VM to expose the Actor class
const vm = new VirtualMachine(program, {
    classes: {
        Actor: {
            constructor: Actor,
            // Only these members are visible to Luma:
            methods: [ 'greet' ],
            properties: [ 'name' ],
        },
    },
});

vm.run();
```

**Output:**

```text
Hello, Luma User!
```

By strictly defining `methods` and `properties` in the configuration object,
you define the API surface available to the script while keeping the rest of
your host application logic private.

### Inheritance with Host Classes

Host classes are first-class citizens within the Luma type system. Luma scripts
can extend host classes to add new functionality while retaining the underlying
host logic.

```luma
class Player extends Actor:
    
    // Luma constructor
    fn init(name):
        this.name = name

    fn introduce():
        print("I am " + this.name)
        
player = new Player("Alice")
player.introduce()  // Prints "I am Alice"
player.greet()      // Calls host method, prints "Hello, Alice!"

// Type checks:
print("Is player an Actor? " + (player is Actor))  // true
print("Is player a Player? " + (player is Player)) // true
```

### Host Functions and Global Variables

In addition to classes, you can inject helper functions and global variables
directly into the script's global scope using the `functions` and `variables`
options.

This is particularly useful for environment configuration or logging utilities.

```ts
const vm = new VirtualMachine(program, {
    functions: {
        // Expose a custom logger
        print: (...args: any[]) => console.log('[VM]: ', ...args),
    },
    variables: {
        // Expose configuration constants
        appName: "LumaApp",
        version: "1.0.0"
    },
});
```

> [!INFO]
> Luma has a built-in `print` function that outputs arguments to `console.log`
> by default. As shown above, you can override this behavior by providing your
> own implementation (e.g., to log to a file or a UI element) via the
> `functions` option.

Inside the Luma script, these are accessed naturally:

```luma
// Uses the overridden print function
print("Welcome to " + appName + " v" + version)
```

**Output:**

```text
[VM]: Welcome to LumaApp v1.0.0
```
